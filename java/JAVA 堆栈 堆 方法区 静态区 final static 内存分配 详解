
1.堆： 运行时的数据区，类的对象从中分配内存；
优点：动态分配，不需要回收，但存取速度慢；



2.  栈：使用后进先出的方式；存取速度仅次于寄存器。
优点：共享数据，但大小和生命周期确定，只能存储基本类型的变量（int byte long char float double boolean short）

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： 
复制内容到剪贴板代码: 
int a = 3; 
int b = 3； 
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。

特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。




3.String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"；的形式来创建

详解字符串的引用：

关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：
(1)先定义一个名为str的对String类的对象引用变量：String str；
(2)在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。
(3)将str指向对象o的地址。
值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用。

一个简单的例子如下：
String str1 = "abc"; 
String str2 = "abc"; 
System.out.println(str1==str2); //true 

我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。
结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。
String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。
不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。


4.final标记的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用
    ·final标记的局部变量可以只声明不赋值，然后再进行一次性的赋值

    .final一般用于标记那些通用性的功能、实现方式或取值不能随意被改变的成分，以避免被误用
  如果将引用类型（即，任何类的类型）的变量标记为final，那么，该变量不能指向任何其它对象，但可以改变对象的内容，因为只有引用本身是final的。


5.static的基本规则
  ·一个类的静态方法只能访问静态属性
  ·一个类的静态方法不能直接调用非静态方法
  ·如访问控制权限允许，static属性和方法可以使用类名加“.”的方式调用，也可以使用实例加“.”的方式调用
  ·静态方法中不存在当前对象，因而不能使用this，也不能使用super
  ·静态方法不能被非静态方法覆盖
  ·构造方法不允许声明为static的
  注，非静态变量只限于实例，并只能通过实例引用被访问。
静态初始器——静态块
  静态初始器是一个存在与类中方法外面的静态块，仅仅在类装载的时候执行一次，通常用来初始化静态的类属性。

6.内部类
  在一个类（或方法、语句块）的内部定义另一个类，后者称为内部类，有时也称为嵌套类。
  内部类的特点
    ·内部类可以体现逻辑上的从属关系，同时对于其它类可以控制内部类对外不可见等
    ·外部类的成员变量作用域是整个外部类，包括内部类，但外部类不能访问内部类的private成员
    ·逻辑上相关的类可以在一起，可以有效地实现信息隐藏
    ·内部类可以直接访问外部类的成员，可以用此实现多继承
    ·编译后，内部类也被编译为单独的类，名称为outclass$inclass的形式
内部类可以分为四种
    ·类级：成员式，有static修饰
    ·对象级：成员式，普通，无static修饰
    ·本地内部类：局部式
    ·匿名级：局部式
  成员式内部类的基本规则
    ·可以有各种修饰符，可以用4种权限、static、final、abstract定义
    ·若有static限定，就为类级，否则为对象级。类级可以通过外部类直接访问，对象级需要先生成外部的对象后才能访问
    ·内外部类不能同名
    ·非静态内部类中不能声明任何static成员
    ·内部类可以互相调用
  成员式内部类的访问
    内部类访问外层类对象的成员时，语法为：
      外层类名.this.属性
    使用内部类时，由外部类对象加“.new”操作符调用内部类的构造方法，创建内部类的对象。
  在另一个外部类中使用非静态内部类中定义的方法时，要先创建外部类的对象，再创建与外部类相关的内部类的对象，再调用内部类的方法。
  static内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可以直接创建。
  由于内部类可以直接访问其外部类的成分，因此，当内部类与其外部类中存在同名属性或方法时，也将导致命名冲突。所以，在多层调用时要指明。

  本地类是定义在代码块中的类，只在定义它们的代码块中可见。
  本地类有以下几个重要特性：
    ·仅在定义了它们的代码块中可见
    ·可以使用定义它们的代码块中的任何本地final变量（注：本地类（也可以是局部内部类/匿名内部类等等）使用外部类的变量，原意是希望这个变量在本地类中的对象和在外部类中的这个变量对象是一致的，但如果这个变量不是final定义，它有可能在外部被修改，从而导致内外部类的变量对象状态不一致，因此，这类变量必须在外部类中加final前缀定义）
    ·本地类不可以是static的，里边也不能定义static成员
    ·本地类不可以用public、private、protected修饰，只能使用缺省的
    ·本地类可以是abstract的
 
匿名内部类是本地内部类的一种特殊形式，即，没有类名的内部类，而且具体的类实现会写在这个内部类里。
  匿名类的规则
    ·匿名类没有构造方法
    ·匿名类不能定义静态的成员
    ·匿名类不能用4种权限、static、final、abstract修饰
    ·只可以创建一个匿名类实例


 7. 方法区，栈内存，堆内存的简介：
 方法区存放装载的类数据信息，包括：
    ·基本信息：每个类的全限定名、每个类的直接超类的全限定名、该类是类还是接口、该类型的访问修饰符、直接超接口的全限定名的有序列表。
    ·每个已装载类的详细信息：运行时常量池、字段信息、方法信息、静态变量、到类classloader的引用、到类class的引用。
  栈内存
    Java栈内存由局部变量区、操作数栈、帧数据区组成，以帧的形式存放本地方法的调用状态（包括方法调用的参数、局部变量、中间结果……）。
  堆内存
    堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
  本地方法栈内存
    Java通过Java本地接口JNI（Java Native Interface）来调用其它语言编写的程序，在Java里面用native修饰符来描述一个方法是本地方法。
  String的内存分配
    String是一个特殊的包装类数据，由于String类的值不可变性，当String变量需要经常变换其值时，应该考虑使用StringBuffer或StringBuilder类，以提高程序效率。


8.方法区  栈内存 堆内存的详细解释：
 1.1 方法区：
 
方法区是系统分配的一个内存逻辑区域，是JVM在装载类文件时，用于存储类型信息的(类的描述信息)。
 
方法区存放的信息包括：
            1.1.1类的基本信息：
每个类的全限定名
每个类的直接超类的全限定名(可约束类型转换)
该类是类还是接口
该类型的访问修饰符
直接超接口的全限定名的有序列表
             1.1.2已装载类的详细信息：
运行时常量池：
在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用）
字段信息：
字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。
字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符
方法信息：
类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。
(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。)
在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。
静态变量：
这个没什么好说的，就是类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块。
到类classloader的引用：到该类的类装载器的引用。
到类class的引用：虚拟机为每一个被装载的类型创建一个class实例，用来代表这个被装载的类。

由此我们可以知道反射的基础：
在装载类的时候，加入方法区中的所有信息，最后都会形成Class类的实例，代表这个被装载的类。方法区中的所有的信息，都是可以通过这个Class类对象反射得到。我们知道对象是类的实例，类是相同结构的对象的一种抽象。同类的各个对象之间，其实是拥有相同的结构（属性），拥有相同的功能（方法），各个对象的区别只在于属性值的不同。
    同样的，我们所有的类，其实都是Class类的实例，他们都拥有相同的结构-----Field数组、Method数组。而各个类中的属性都是Field属性的一个具体属性值，方法都是Method属性的一个具体属性值。
 
在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。

1.2 Java栈
JVM栈是程序运行时单位，决定了程序如何执行，或者说数据如何处理。
 
在Java中，一个线程就会有一个线程的JVM栈与之对应，因为不过的线程执行逻辑显然不同，因此都需要一个独立的JVM栈来存放该线程的执行逻辑。
 
对方法的调用：
            Java栈内存，以帧的形式存放本地方法的调用状态，包括方法调用的参数、局部变量、中间结果等（方法都是以方法帧的形式存放在方法区的），每调用一个方法就将对应该方法的方法帧压入Java栈，成为当前方法帧。当调用结束(返回)时，就弹出该帧。

Java 栈内存的组成：
局部变量区、操作数栈、帧数据区组成。
（1）：局部变量区为一个以字为单位的数组，每个数组元素对应一个局部变量的值。调用方法时，将方法的局部变量组成一个数组，通过索引来访问。若为非静态方法，则加入一个隐含的引用参数this,该参数指向调用这个方法的对象。而静态方法则没有this参数。因此，对象无法调用静态方法。
由此，我们可以知道，方法什么时候设计为静态，什么时候为非静态？
前面已经说过，对象是类的一个实例，各个对象结构相同，只是属性不同。
而静态方法是对象无法调用的。
所以，静态方法适合那些工具类中的工具方法，这些类只是用来实现一些功能，也不需要产生对象，通过设置对象的属性来得到各个不同的个体。

（2）：操作数栈也是一个数组，但是通过栈操作来访问。所谓操作数是那些被指令操作的数据。当需要对参数操作时如a=b+c,就将即将被操作的参数压栈，如将b 和c 压栈，然后由操作指令将它们弹出，并执行操作。虚拟机将操作数栈作为工作区。
（3）：帧数据区处理常量池解析，异常处理等


1.3 java堆
      java的堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。
      在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
 
    由此我们可以知道,引用类型变量和对象的区别:
 
声明的对象是在堆内存中初始化的， 真正用来存储数据的。不能直接访问。
引用类型变量是保存在栈当中的，一个用来引用堆中对象的符号而已（指针）。
  
9.堆与栈的比较：
JAVA堆与栈都是用来存放数据的，那么他们之间到底有什么差异呢？既然栈也能存放数据，为什么还要设计堆呢？

1.从存放数据的角度:
      前面我们已经说明:
 
      栈中存放的是基本类型的变量or引用类型的变量
       堆中存放的是对象or数组对象.
       在栈中，引用变量的大小为32位，基本类型为1-8个字节。
       但是对象的大小和数组的大小是动态的，这也决定了堆中数据的动态性，因为它是在运行时动态分配内存的，生存期也不必在编译时确定，Java 的垃圾收集器会自动收走这些不再使用的数据。
  
2.从数据共享的角度:
    1).在单个线程类，栈中的数据可共享
    例如我们定义：
Java代码
int a=3; 
int b=3; 
int a=3; int b=3;
    编译器先处理int a = 3；首先它会在栈中创建一个变量为a 的引用，然后查找栈中是否有3 这个值，如果没找到，就将3 存放进来，然后将a 指向3。接着处理int b = 3；在创建完b 的引用变量后，因为在栈中已经有3这个值，便将b 直接指向3。这样，就出现了a 与b 同时均指向3的情况。
    而如果我们定义：
Java代码
Integer a=new Integer(3);//(1) 
Integer b=new Integer(3);//(2) 
Integer a=new Integer(3);//(1) Integer b=new Integer(3);//(2)
   这个时候执行过程为：在执行(1)时，首先在栈中创建一个变量a，然后在堆内存中实例化一个对象，并且将变量a指向这个实例化的对象。在执行(2)时，过程类似，此时，在堆内存中，会有两个Integer类型的对象。 
    2).在进程的各个线程之间，数据的共享通过堆来实现
        例：那么，在多线程开发中，我们的数据共享又是怎么实现的呢？

  如图所示，堆中的数据是所有线程栈所共享的，我们可以通过参数传递，将一个堆中的数据传入各个栈的工作内存中，从而实现多个线程间的数据共享
（多个进程间的数据共享则需要通过网络传输了。）
3.从程序设计的的角度:
从软件设计的角度看，JVM栈代表了处理逻辑，而JVM堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
4.值传递和引用传递的真相
有了以上关于栈和堆的种种了解后，我们很容易就可以知道值传递和引用传递的真相：
1.程序运行永远都是在JVM栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。
但是传引用的错觉是如何造成的呢?
在运行JVM栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。
但是当进入被调用方法时，被传递的这个引用的值，被程序解释(或者查找)到JVM堆中的对象，这个时候才对应到真正的对象。
如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是JVM堆中的数据。所以这个修改是可以保持的了。
最后：
从某种意义上来说对象都是由基本类型组成的。
可以把一个对象看作为一棵树，对象的属性如果还是对象，则还是一颗树(即非叶子节点)，基本类型则为树的叶子节点。程序参数传递时，被传递的值本身都是不能进行修改的，但是，如果这个值是一个非叶子节点(即一个对象引用)，则可以修改这个节点下面的所有内容。
 
其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。
面向对象的引入，只是改变了我们对待问题的思考方式，而更接近于自然方式的思考。
当我们把对象拆开，其实对象的属性就是数据，存放在JVM堆中;而对象的行为(方法)，就是运行逻辑，放在JVM栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。
