泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。----就是参数化类型，在具体使用时传入具体的类型；

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

注意点：
1.泛型的类型参数只能是类类型，不能是简单类型。
2.不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。
if(ex_num instanceof Generic<Number>){   
} 
3.通配符：

两个传入不同泛型参数的实现类，它们的泛型参数是继承关系不能说明这两个类是继承关系，例如：Generic<Integer>不能被看作为`Generic<Number>的子类---其中Integer 是Number的子类。

那么如果我需要这个泛型类作为一个方法参数，然后这个方法可以同时使用这两个泛型实现类作为参数传入呢？ 使用通配符 Generic<?> obj）或者使用泛型上限Generic<? extends Number>也是可以的；

4.泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型，也就是你传入的参数是什么类型就是什么类型。但是两者在定义的时候都是需要进行声明的；

5.静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。



1.泛型方法：
public static <AnyType> AnyType getMax(AnyType[] arr){
}

2.泛型类
public class Test<AnyType> {
    AnyType zhou;

    public AnyType getZhou() {
        return zhou;
    }

    public void setZhou(AnyType zhou) {
        this.zhou = zhou;
    }
}

泛型类的作用就是这个类里面可以有参数类型或者返回值的类型，等到实际使用时才去确定；泛型需要在类的定义的大括号之前进行声明；



3.泛型接口：  
public interface IpmlTest<AnyType>{
	void getMax(AnyType a){	
	}
}

反应接口的作用就是  这个泛型参数类型可以等到具体使用时才去确定  泛型也是需要在定义的大括号之前进行声明；
