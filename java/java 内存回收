Java的GC机制是自动进行的，和c语言有些区别需要程序员自己保证内存的使用和回收。
Java的内存分配和回收也主要在Java的堆上进行的，Java的堆中存储了大量的对象实例，所以Java的堆也叫GC堆。
Java在垃圾收集的过程中，主要用到了分代收集算法，我会先讲一下常用垃圾收集算法。



--------------------常用的回收算法--------------



标记--压缩：
①支持压缩的垃圾回收器（标记-压缩 = 标记清除+压缩）会把所有的可达对象搬迁到一端，然后直接清理掉端边界以外的内存，减少了内存碎片。

标记--清除
不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片

标记--复制
将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。


--------------------java的分代回收--------------

Java的内存回收：
Java主要采用了分代收集算法。分代收集算法主要将对象存活期的长短将内存进行划分。
Java主要将内存划分为两部分：新生代和老生代
Java的新生代中，对象的存活率低，存活期期会相对会比较短一些，所以可以选用复制算法来进行内存回收。
Java的老生代中，对象的存活率比较高，并且相对存活期比较长一些，可以采用标记-清除-压缩的算法来进行内存回收。


--------------------分代回收的依据--------------

分代回收的依据：
①对象生存时间的长短：大部分对象在Young期间就被回收
②不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用

--------------------新生代 和 老生代 和 永久代 的具体回收机制--------------

①Young代 ：

Ⅰ回收机制 ：因为对象数量少，所以采用复制回收。

Ⅱ组成区域 ：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。

Ⅲ对象来源 ：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。

Ⅳ回收频率 ：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快。

②Old代 ：

Ⅰ回收机制 ：采用标记压缩算法回收。

Ⅱ对象来源 ：1.对象大直接进入老年代。

2.Young代中生存时间长的可达对象

Ⅲ回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。

③Permanent代 ：

Ⅰ用      途 ：用来装载Class，方法等信息，默认为64M，不会被回收

Ⅱ对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。

Ⅲ回收频率 ：不会被回收


-------------------常见的垃圾回收器-------------


在此之前，我们先讲一下下面将会涉及到的并发和并行两个词的解释：

1）并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；

2）并发：指用户线程与 垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序继续执行，而垃圾收集程序运行于另一个CPU上。

好啦，继续讲垃圾回收器：

1）串行回收器（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，

2）并行回收器：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程。

3）并行压缩回收器：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：

① 将Old代划分成几个固定区域；

② mark阶段（多线程并行），标记可达对象；

③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域

④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。

4）并发标识—清理回收（CMS）：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：

① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；

② 并发标识（程序运行）：通过一级对象寻找其他可达对象；

③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）

④ 并发清理（程序运行）



--------------------内存管理小技巧---------------------------

1）尽量使用直接量，eg：String javaStr = “小学徒的成长历程”;

2）使用StringBuilder和StringBuffer进行字符串连接等操作;

3）尽早释放无用对象;

4）尽量少使用静态变量;

5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;

6）尽量不使用finalize()方法;

7）在必要的时候可以考虑使用软引用SoftReference。


简单的对象之间的联系：
http://www.importnew.com/15330.html




